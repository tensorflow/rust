// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/protobuf/saved_object_graph.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct SavedObjectGraph {
    // message fields
    pub nodes: ::protobuf::RepeatedField<SavedObject>,
    pub concrete_functions: ::std::collections::HashMap<::std::string::String, SavedConcreteFunction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedObjectGraph {
    fn default() -> &'a SavedObjectGraph {
        <SavedObjectGraph as ::protobuf::Message>::default_instance()
    }
}

impl SavedObjectGraph {
    pub fn new() -> SavedObjectGraph {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.SavedObject nodes = 1;


    pub fn get_nodes(&self) -> &[SavedObject] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<SavedObject>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<SavedObject> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<SavedObject> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.SavedObjectGraph.ConcreteFunctionsEntry concrete_functions = 2;


    pub fn get_concrete_functions(&self) -> &::std::collections::HashMap<::std::string::String, SavedConcreteFunction> {
        &self.concrete_functions
    }
    pub fn clear_concrete_functions(&mut self) {
        self.concrete_functions.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_functions(&mut self, v: ::std::collections::HashMap<::std::string::String, SavedConcreteFunction>) {
        self.concrete_functions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concrete_functions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, SavedConcreteFunction> {
        &mut self.concrete_functions
    }

    // Take field
    pub fn take_concrete_functions(&mut self) -> ::std::collections::HashMap<::std::string::String, SavedConcreteFunction> {
        ::std::mem::replace(&mut self.concrete_functions, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SavedObjectGraph {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(wire_type, is, &mut self.concrete_functions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(2, &self.concrete_functions);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(2, &self.concrete_functions, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedObjectGraph {
        SavedObjectGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedObject>>(
                "nodes",
                |m: &SavedObjectGraph| { &m.nodes },
                |m: &mut SavedObjectGraph| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SavedConcreteFunction>>(
                "concrete_functions",
                |m: &SavedObjectGraph| { &m.concrete_functions },
                |m: &mut SavedObjectGraph| { &mut m.concrete_functions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedObjectGraph>(
                "SavedObjectGraph",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedObjectGraph {
        static instance: ::protobuf::rt::LazyV2<SavedObjectGraph> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedObjectGraph::new)
    }
}

impl ::protobuf::Clear for SavedObjectGraph {
    fn clear(&mut self) {
        self.nodes.clear();
        self.concrete_functions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedObjectGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedObjectGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedObject {
    // message fields
    pub children: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference>,
    pub slot_variables: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference>,
    pub saveable_objects: ::std::collections::HashMap<::std::string::String, SaveableObject>,
    // message oneof groups
    pub kind: ::std::option::Option<SavedObject_oneof_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedObject {
    fn default() -> &'a SavedObject {
        <SavedObject as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SavedObject_oneof_kind {
    user_object(SavedUserObject),
    asset(SavedAsset),
    function(SavedFunction),
    variable(SavedVariable),
    bare_concrete_function(SavedBareConcreteFunction),
    constant(SavedConstant),
    resource(SavedResource),
    captured_tensor(CapturedTensor),
}

impl SavedObject {
    pub fn new() -> SavedObject {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.TrackableObjectGraph.TrackableObject.ObjectReference children = 1;


    pub fn get_children(&self) -> &[super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.TrackableObjectGraph.TrackableObject.SlotVariableReference slot_variables = 3;


    pub fn get_slot_variables(&self) -> &[super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference] {
        &self.slot_variables
    }
    pub fn clear_slot_variables(&mut self) {
        self.slot_variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_slot_variables(&mut self, v: ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference>) {
        self.slot_variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slot_variables(&mut self) -> &mut ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference> {
        &mut self.slot_variables
    }

    // Take field
    pub fn take_slot_variables(&mut self) -> ::protobuf::RepeatedField<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference> {
        ::std::mem::replace(&mut self.slot_variables, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.SavedUserObject user_object = 4;


    pub fn get_user_object(&self) -> &SavedUserObject {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::user_object(ref v)) => v,
            _ => <SavedUserObject as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_user_object(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_user_object(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::user_object(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_object(&mut self, v: SavedUserObject) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::user_object(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_object(&mut self) -> &mut SavedUserObject {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::user_object(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::user_object(SavedUserObject::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::user_object(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_object(&mut self) -> SavedUserObject {
        if self.has_user_object() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::user_object(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedUserObject::new()
        }
    }

    // .tensorflow.SavedAsset asset = 5;


    pub fn get_asset(&self) -> &SavedAsset {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::asset(ref v)) => v,
            _ => <SavedAsset as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_asset(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_asset(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::asset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_asset(&mut self, v: SavedAsset) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::asset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_asset(&mut self) -> &mut SavedAsset {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::asset(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::asset(SavedAsset::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::asset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_asset(&mut self) -> SavedAsset {
        if self.has_asset() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::asset(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedAsset::new()
        }
    }

    // .tensorflow.SavedFunction function = 6;


    pub fn get_function(&self) -> &SavedFunction {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::function(ref v)) => v,
            _ => <SavedFunction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_function(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_function(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: SavedFunction) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function(&mut self) -> &mut SavedFunction {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::function(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::function(SavedFunction::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function(&mut self) -> SavedFunction {
        if self.has_function() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::function(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedFunction::new()
        }
    }

    // .tensorflow.SavedVariable variable = 7;


    pub fn get_variable(&self) -> &SavedVariable {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::variable(ref v)) => v,
            _ => <SavedVariable as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_variable(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_variable(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::variable(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: SavedVariable) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::variable(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variable(&mut self) -> &mut SavedVariable {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::variable(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::variable(SavedVariable::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::variable(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variable(&mut self) -> SavedVariable {
        if self.has_variable() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::variable(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedVariable::new()
        }
    }

    // .tensorflow.SavedBareConcreteFunction bare_concrete_function = 8;


    pub fn get_bare_concrete_function(&self) -> &SavedBareConcreteFunction {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(ref v)) => v,
            _ => <SavedBareConcreteFunction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bare_concrete_function(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_bare_concrete_function(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bare_concrete_function(&mut self, v: SavedBareConcreteFunction) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bare_concrete_function(&mut self) -> &mut SavedBareConcreteFunction {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(SavedBareConcreteFunction::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bare_concrete_function(&mut self) -> SavedBareConcreteFunction {
        if self.has_bare_concrete_function() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedBareConcreteFunction::new()
        }
    }

    // .tensorflow.SavedConstant constant = 9;


    pub fn get_constant(&self) -> &SavedConstant {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::constant(ref v)) => v,
            _ => <SavedConstant as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_constant(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_constant(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::constant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_constant(&mut self, v: SavedConstant) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::constant(v))
    }

    // Mutable pointer to the field.
    pub fn mut_constant(&mut self) -> &mut SavedConstant {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::constant(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::constant(SavedConstant::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::constant(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_constant(&mut self) -> SavedConstant {
        if self.has_constant() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::constant(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedConstant::new()
        }
    }

    // .tensorflow.SavedResource resource = 10;


    pub fn get_resource(&self) -> &SavedResource {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::resource(ref v)) => v,
            _ => <SavedResource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_resource(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_resource(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::resource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: SavedResource) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::resource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resource(&mut self) -> &mut SavedResource {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::resource(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::resource(SavedResource::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::resource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resource(&mut self) -> SavedResource {
        if self.has_resource() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::resource(v)) => v,
                _ => panic!(),
            }
        } else {
            SavedResource::new()
        }
    }

    // .tensorflow.CapturedTensor captured_tensor = 12;


    pub fn get_captured_tensor(&self) -> &CapturedTensor {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(ref v)) => v,
            _ => <CapturedTensor as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_captured_tensor(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_captured_tensor(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_captured_tensor(&mut self, v: CapturedTensor) {
        self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_captured_tensor(&mut self) -> &mut CapturedTensor {
        if let ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(CapturedTensor::new()));
        }
        match self.kind {
            ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_captured_tensor(&mut self) -> CapturedTensor {
        if self.has_captured_tensor() {
            match self.kind.take() {
                ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(v)) => v,
                _ => panic!(),
            }
        } else {
            CapturedTensor::new()
        }
    }

    // repeated .tensorflow.SavedObject.SaveableObjectsEntry saveable_objects = 11;


    pub fn get_saveable_objects(&self) -> &::std::collections::HashMap<::std::string::String, SaveableObject> {
        &self.saveable_objects
    }
    pub fn clear_saveable_objects(&mut self) {
        self.saveable_objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_saveable_objects(&mut self, v: ::std::collections::HashMap<::std::string::String, SaveableObject>) {
        self.saveable_objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_saveable_objects(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, SaveableObject> {
        &mut self.saveable_objects
    }

    // Take field
    pub fn take_saveable_objects(&mut self) -> ::std::collections::HashMap<::std::string::String, SaveableObject> {
        ::std::mem::replace(&mut self.saveable_objects, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SavedObject {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slot_variables {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(SavedObject_oneof_kind::user_object(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::asset(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::function(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::variable(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::bare_concrete_function(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::constant(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::resource(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SavedObject_oneof_kind::captured_tensor(ref v)) = self.kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slot_variables)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::user_object(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::asset(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::function(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::variable(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::bare_concrete_function(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::constant(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::resource(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = ::std::option::Option::Some(SavedObject_oneof_kind::captured_tensor(is.read_message()?));
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SaveableObject>>(wire_type, is, &mut self.saveable_objects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.slot_variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SaveableObject>>(11, &self.saveable_objects);
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &SavedObject_oneof_kind::user_object(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::asset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::function(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::variable(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::bare_concrete_function(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::constant(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::resource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SavedObject_oneof_kind::captured_tensor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.children {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.slot_variables {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SaveableObject>>(11, &self.saveable_objects, os)?;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &SavedObject_oneof_kind::user_object(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::asset(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::function(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::variable(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::bare_concrete_function(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::constant(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::resource(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SavedObject_oneof_kind::captured_tensor(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedObject {
        SavedObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_ObjectReference>>(
                "children",
                |m: &SavedObject| { &m.children },
                |m: &mut SavedObject| { &mut m.children },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trackable_object_graph::TrackableObjectGraph_TrackableObject_SlotVariableReference>>(
                "slot_variables",
                |m: &SavedObject| { &m.slot_variables },
                |m: &mut SavedObject| { &mut m.slot_variables },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedUserObject>(
                "user_object",
                SavedObject::has_user_object,
                SavedObject::get_user_object,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedAsset>(
                "asset",
                SavedObject::has_asset,
                SavedObject::get_asset,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedFunction>(
                "function",
                SavedObject::has_function,
                SavedObject::get_function,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedVariable>(
                "variable",
                SavedObject::has_variable,
                SavedObject::get_variable,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedBareConcreteFunction>(
                "bare_concrete_function",
                SavedObject::has_bare_concrete_function,
                SavedObject::get_bare_concrete_function,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedConstant>(
                "constant",
                SavedObject::has_constant,
                SavedObject::get_constant,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SavedResource>(
                "resource",
                SavedObject::has_resource,
                SavedObject::get_resource,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CapturedTensor>(
                "captured_tensor",
                SavedObject::has_captured_tensor,
                SavedObject::get_captured_tensor,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SaveableObject>>(
                "saveable_objects",
                |m: &SavedObject| { &m.saveable_objects },
                |m: &mut SavedObject| { &mut m.saveable_objects },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedObject>(
                "SavedObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedObject {
        static instance: ::protobuf::rt::LazyV2<SavedObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedObject::new)
    }
}

impl ::protobuf::Clear for SavedObject {
    fn clear(&mut self) {
        self.children.clear();
        self.slot_variables.clear();
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.saveable_objects.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedUserObject {
    // message fields
    pub identifier: ::std::string::String,
    pub version: ::protobuf::SingularPtrField<super::versions::VersionDef>,
    pub metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedUserObject {
    fn default() -> &'a SavedUserObject {
        <SavedUserObject as ::protobuf::Message>::default_instance()
    }
}

impl SavedUserObject {
    pub fn new() -> SavedUserObject {
        ::std::default::Default::default()
    }

    // string identifier = 1;


    pub fn get_identifier(&self) -> &str {
        &self.identifier
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.identifier
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identifier, ::std::string::String::new())
    }

    // .tensorflow.VersionDef version = 2;


    pub fn get_version(&self) -> &super::versions::VersionDef {
        self.version.as_ref().unwrap_or_else(|| <super::versions::VersionDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: super::versions::VersionDef) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut super::versions::VersionDef {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> super::versions::VersionDef {
        self.version.take().unwrap_or_else(|| super::versions::VersionDef::new())
    }

    // string metadata = 3;


    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedUserObject {
    fn is_initialized(&self) -> bool {
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identifier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identifier);
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identifier.is_empty() {
            os.write_string(1, &self.identifier)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(3, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedUserObject {
        SavedUserObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &SavedUserObject| { &m.identifier },
                |m: &mut SavedUserObject| { &mut m.identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::versions::VersionDef>>(
                "version",
                |m: &SavedUserObject| { &m.version },
                |m: &mut SavedUserObject| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &SavedUserObject| { &m.metadata },
                |m: &mut SavedUserObject| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedUserObject>(
                "SavedUserObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedUserObject {
        static instance: ::protobuf::rt::LazyV2<SavedUserObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedUserObject::new)
    }
}

impl ::protobuf::Clear for SavedUserObject {
    fn clear(&mut self) {
        self.identifier.clear();
        self.version.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedUserObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedUserObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedAsset {
    // message fields
    pub asset_file_def_index: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedAsset {
    fn default() -> &'a SavedAsset {
        <SavedAsset as ::protobuf::Message>::default_instance()
    }
}

impl SavedAsset {
    pub fn new() -> SavedAsset {
        ::std::default::Default::default()
    }

    // int32 asset_file_def_index = 1;


    pub fn get_asset_file_def_index(&self) -> i32 {
        self.asset_file_def_index
    }
    pub fn clear_asset_file_def_index(&mut self) {
        self.asset_file_def_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_asset_file_def_index(&mut self, v: i32) {
        self.asset_file_def_index = v;
    }
}

impl ::protobuf::Message for SavedAsset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.asset_file_def_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.asset_file_def_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.asset_file_def_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.asset_file_def_index != 0 {
            os.write_int32(1, self.asset_file_def_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedAsset {
        SavedAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "asset_file_def_index",
                |m: &SavedAsset| { &m.asset_file_def_index },
                |m: &mut SavedAsset| { &mut m.asset_file_def_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedAsset>(
                "SavedAsset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedAsset {
        static instance: ::protobuf::rt::LazyV2<SavedAsset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedAsset::new)
    }
}

impl ::protobuf::Clear for SavedAsset {
    fn clear(&mut self) {
        self.asset_file_def_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedAsset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedFunction {
    // message fields
    pub concrete_functions: ::protobuf::RepeatedField<::std::string::String>,
    pub function_spec: ::protobuf::SingularPtrField<FunctionSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedFunction {
    fn default() -> &'a SavedFunction {
        <SavedFunction as ::protobuf::Message>::default_instance()
    }
}

impl SavedFunction {
    pub fn new() -> SavedFunction {
        ::std::default::Default::default()
    }

    // repeated string concrete_functions = 1;


    pub fn get_concrete_functions(&self) -> &[::std::string::String] {
        &self.concrete_functions
    }
    pub fn clear_concrete_functions(&mut self) {
        self.concrete_functions.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_functions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concrete_functions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concrete_functions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concrete_functions
    }

    // Take field
    pub fn take_concrete_functions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concrete_functions, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.FunctionSpec function_spec = 2;


    pub fn get_function_spec(&self) -> &FunctionSpec {
        self.function_spec.as_ref().unwrap_or_else(|| <FunctionSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function_spec(&mut self) {
        self.function_spec.clear();
    }

    pub fn has_function_spec(&self) -> bool {
        self.function_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_spec(&mut self, v: FunctionSpec) {
        self.function_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_spec(&mut self) -> &mut FunctionSpec {
        if self.function_spec.is_none() {
            self.function_spec.set_default();
        }
        self.function_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_spec(&mut self) -> FunctionSpec {
        self.function_spec.take().unwrap_or_else(|| FunctionSpec::new())
    }
}

impl ::protobuf::Message for SavedFunction {
    fn is_initialized(&self) -> bool {
        for v in &self.function_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concrete_functions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.concrete_functions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.function_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.concrete_functions {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.function_spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedFunction {
        SavedFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concrete_functions",
                |m: &SavedFunction| { &m.concrete_functions },
                |m: &mut SavedFunction| { &mut m.concrete_functions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FunctionSpec>>(
                "function_spec",
                |m: &SavedFunction| { &m.function_spec },
                |m: &mut SavedFunction| { &mut m.function_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedFunction>(
                "SavedFunction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedFunction {
        static instance: ::protobuf::rt::LazyV2<SavedFunction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedFunction::new)
    }
}

impl ::protobuf::Clear for SavedFunction {
    fn clear(&mut self) {
        self.concrete_functions.clear();
        self.function_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CapturedTensor {
    // message fields
    pub name: ::std::string::String,
    pub concrete_function: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CapturedTensor {
    fn default() -> &'a CapturedTensor {
        <CapturedTensor as ::protobuf::Message>::default_instance()
    }
}

impl CapturedTensor {
    pub fn new() -> CapturedTensor {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string concrete_function = 2;


    pub fn get_concrete_function(&self) -> &str {
        &self.concrete_function
    }
    pub fn clear_concrete_function(&mut self) {
        self.concrete_function.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_function(&mut self, v: ::std::string::String) {
        self.concrete_function = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concrete_function(&mut self) -> &mut ::std::string::String {
        &mut self.concrete_function
    }

    // Take field
    pub fn take_concrete_function(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concrete_function, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CapturedTensor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concrete_function)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.concrete_function.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concrete_function);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.concrete_function.is_empty() {
            os.write_string(2, &self.concrete_function)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CapturedTensor {
        CapturedTensor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CapturedTensor| { &m.name },
                |m: &mut CapturedTensor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concrete_function",
                |m: &CapturedTensor| { &m.concrete_function },
                |m: &mut CapturedTensor| { &mut m.concrete_function },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CapturedTensor>(
                "CapturedTensor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CapturedTensor {
        static instance: ::protobuf::rt::LazyV2<CapturedTensor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CapturedTensor::new)
    }
}

impl ::protobuf::Clear for CapturedTensor {
    fn clear(&mut self) {
        self.name.clear();
        self.concrete_function.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapturedTensor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapturedTensor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedConcreteFunction {
    // message fields
    pub bound_inputs: ::std::vec::Vec<i32>,
    pub canonicalized_input_signature: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    pub output_signature: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedConcreteFunction {
    fn default() -> &'a SavedConcreteFunction {
        <SavedConcreteFunction as ::protobuf::Message>::default_instance()
    }
}

impl SavedConcreteFunction {
    pub fn new() -> SavedConcreteFunction {
        ::std::default::Default::default()
    }

    // repeated int32 bound_inputs = 2;


    pub fn get_bound_inputs(&self) -> &[i32] {
        &self.bound_inputs
    }
    pub fn clear_bound_inputs(&mut self) {
        self.bound_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_bound_inputs(&mut self, v: ::std::vec::Vec<i32>) {
        self.bound_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bound_inputs(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.bound_inputs
    }

    // Take field
    pub fn take_bound_inputs(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.bound_inputs, ::std::vec::Vec::new())
    }

    // .tensorflow.StructuredValue canonicalized_input_signature = 3;


    pub fn get_canonicalized_input_signature(&self) -> &super::struct_pb::StructuredValue {
        self.canonicalized_input_signature.as_ref().unwrap_or_else(|| <super::struct_pb::StructuredValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_canonicalized_input_signature(&mut self) {
        self.canonicalized_input_signature.clear();
    }

    pub fn has_canonicalized_input_signature(&self) -> bool {
        self.canonicalized_input_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonicalized_input_signature(&mut self, v: super::struct_pb::StructuredValue) {
        self.canonicalized_input_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonicalized_input_signature(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.canonicalized_input_signature.is_none() {
            self.canonicalized_input_signature.set_default();
        }
        self.canonicalized_input_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonicalized_input_signature(&mut self) -> super::struct_pb::StructuredValue {
        self.canonicalized_input_signature.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }

    // .tensorflow.StructuredValue output_signature = 4;


    pub fn get_output_signature(&self) -> &super::struct_pb::StructuredValue {
        self.output_signature.as_ref().unwrap_or_else(|| <super::struct_pb::StructuredValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_signature(&mut self) {
        self.output_signature.clear();
    }

    pub fn has_output_signature(&self) -> bool {
        self.output_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_signature(&mut self, v: super::struct_pb::StructuredValue) {
        self.output_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_signature(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.output_signature.is_none() {
            self.output_signature.set_default();
        }
        self.output_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_signature(&mut self) -> super::struct_pb::StructuredValue {
        self.output_signature.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }
}

impl ::protobuf::Message for SavedConcreteFunction {
    fn is_initialized(&self) -> bool {
        for v in &self.canonicalized_input_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.bound_inputs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.canonicalized_input_signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bound_inputs {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.canonicalized_input_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bound_inputs {
            os.write_int32(2, *v)?;
        };
        if let Some(ref v) = self.canonicalized_input_signature.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_signature.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedConcreteFunction {
        SavedConcreteFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bound_inputs",
                |m: &SavedConcreteFunction| { &m.bound_inputs },
                |m: &mut SavedConcreteFunction| { &mut m.bound_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                "canonicalized_input_signature",
                |m: &SavedConcreteFunction| { &m.canonicalized_input_signature },
                |m: &mut SavedConcreteFunction| { &mut m.canonicalized_input_signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                "output_signature",
                |m: &SavedConcreteFunction| { &m.output_signature },
                |m: &mut SavedConcreteFunction| { &mut m.output_signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedConcreteFunction>(
                "SavedConcreteFunction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedConcreteFunction {
        static instance: ::protobuf::rt::LazyV2<SavedConcreteFunction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedConcreteFunction::new)
    }
}

impl ::protobuf::Clear for SavedConcreteFunction {
    fn clear(&mut self) {
        self.bound_inputs.clear();
        self.canonicalized_input_signature.clear();
        self.output_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedConcreteFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedConcreteFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedBareConcreteFunction {
    // message fields
    pub concrete_function_name: ::std::string::String,
    pub argument_keywords: ::protobuf::RepeatedField<::std::string::String>,
    pub allowed_positional_arguments: i64,
    pub function_spec: ::protobuf::SingularPtrField<FunctionSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedBareConcreteFunction {
    fn default() -> &'a SavedBareConcreteFunction {
        <SavedBareConcreteFunction as ::protobuf::Message>::default_instance()
    }
}

impl SavedBareConcreteFunction {
    pub fn new() -> SavedBareConcreteFunction {
        ::std::default::Default::default()
    }

    // string concrete_function_name = 1;


    pub fn get_concrete_function_name(&self) -> &str {
        &self.concrete_function_name
    }
    pub fn clear_concrete_function_name(&mut self) {
        self.concrete_function_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_concrete_function_name(&mut self, v: ::std::string::String) {
        self.concrete_function_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concrete_function_name(&mut self) -> &mut ::std::string::String {
        &mut self.concrete_function_name
    }

    // Take field
    pub fn take_concrete_function_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concrete_function_name, ::std::string::String::new())
    }

    // repeated string argument_keywords = 2;


    pub fn get_argument_keywords(&self) -> &[::std::string::String] {
        &self.argument_keywords
    }
    pub fn clear_argument_keywords(&mut self) {
        self.argument_keywords.clear();
    }

    // Param is passed by value, moved
    pub fn set_argument_keywords(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.argument_keywords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_argument_keywords(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.argument_keywords
    }

    // Take field
    pub fn take_argument_keywords(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.argument_keywords, ::protobuf::RepeatedField::new())
    }

    // int64 allowed_positional_arguments = 3;


    pub fn get_allowed_positional_arguments(&self) -> i64 {
        self.allowed_positional_arguments
    }
    pub fn clear_allowed_positional_arguments(&mut self) {
        self.allowed_positional_arguments = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowed_positional_arguments(&mut self, v: i64) {
        self.allowed_positional_arguments = v;
    }

    // .tensorflow.FunctionSpec function_spec = 4;


    pub fn get_function_spec(&self) -> &FunctionSpec {
        self.function_spec.as_ref().unwrap_or_else(|| <FunctionSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function_spec(&mut self) {
        self.function_spec.clear();
    }

    pub fn has_function_spec(&self) -> bool {
        self.function_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_spec(&mut self, v: FunctionSpec) {
        self.function_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_spec(&mut self) -> &mut FunctionSpec {
        if self.function_spec.is_none() {
            self.function_spec.set_default();
        }
        self.function_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_spec(&mut self) -> FunctionSpec {
        self.function_spec.take().unwrap_or_else(|| FunctionSpec::new())
    }
}

impl ::protobuf::Message for SavedBareConcreteFunction {
    fn is_initialized(&self) -> bool {
        for v in &self.function_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concrete_function_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.argument_keywords)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowed_positional_arguments = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.concrete_function_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.concrete_function_name);
        }
        for value in &self.argument_keywords {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.allowed_positional_arguments != 0 {
            my_size += ::protobuf::rt::value_size(3, self.allowed_positional_arguments, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.function_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.concrete_function_name.is_empty() {
            os.write_string(1, &self.concrete_function_name)?;
        }
        for v in &self.argument_keywords {
            os.write_string(2, &v)?;
        };
        if self.allowed_positional_arguments != 0 {
            os.write_int64(3, self.allowed_positional_arguments)?;
        }
        if let Some(ref v) = self.function_spec.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedBareConcreteFunction {
        SavedBareConcreteFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concrete_function_name",
                |m: &SavedBareConcreteFunction| { &m.concrete_function_name },
                |m: &mut SavedBareConcreteFunction| { &mut m.concrete_function_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "argument_keywords",
                |m: &SavedBareConcreteFunction| { &m.argument_keywords },
                |m: &mut SavedBareConcreteFunction| { &mut m.argument_keywords },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "allowed_positional_arguments",
                |m: &SavedBareConcreteFunction| { &m.allowed_positional_arguments },
                |m: &mut SavedBareConcreteFunction| { &mut m.allowed_positional_arguments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FunctionSpec>>(
                "function_spec",
                |m: &SavedBareConcreteFunction| { &m.function_spec },
                |m: &mut SavedBareConcreteFunction| { &mut m.function_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedBareConcreteFunction>(
                "SavedBareConcreteFunction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedBareConcreteFunction {
        static instance: ::protobuf::rt::LazyV2<SavedBareConcreteFunction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedBareConcreteFunction::new)
    }
}

impl ::protobuf::Clear for SavedBareConcreteFunction {
    fn clear(&mut self) {
        self.concrete_function_name.clear();
        self.argument_keywords.clear();
        self.allowed_positional_arguments = 0;
        self.function_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedBareConcreteFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedBareConcreteFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedConstant {
    // message fields
    pub operation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedConstant {
    fn default() -> &'a SavedConstant {
        <SavedConstant as ::protobuf::Message>::default_instance()
    }
}

impl SavedConstant {
    pub fn new() -> SavedConstant {
        ::std::default::Default::default()
    }

    // string operation = 1;


    pub fn get_operation(&self) -> &str {
        &self.operation
    }
    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        &mut self.operation
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedConstant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.operation.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.operation.is_empty() {
            os.write_string(1, &self.operation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedConstant {
        SavedConstant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation",
                |m: &SavedConstant| { &m.operation },
                |m: &mut SavedConstant| { &mut m.operation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedConstant>(
                "SavedConstant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedConstant {
        static instance: ::protobuf::rt::LazyV2<SavedConstant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedConstant::new)
    }
}

impl ::protobuf::Clear for SavedConstant {
    fn clear(&mut self) {
        self.operation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedConstant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedConstant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedVariable {
    // message fields
    pub dtype: super::types::DataType,
    pub shape: ::protobuf::SingularPtrField<super::tensor_shape::TensorShapeProto>,
    pub trainable: bool,
    pub synchronization: super::variable::VariableSynchronization,
    pub aggregation: super::variable::VariableAggregation,
    pub name: ::std::string::String,
    pub device: ::std::string::String,
    pub experimental_distributed_variable_components: ::protobuf::RepeatedField<SavedVariable>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedVariable {
    fn default() -> &'a SavedVariable {
        <SavedVariable as ::protobuf::Message>::default_instance()
    }
}

impl SavedVariable {
    pub fn new() -> SavedVariable {
        ::std::default::Default::default()
    }

    // .tensorflow.DataType dtype = 1;


    pub fn get_dtype(&self) -> super::types::DataType {
        self.dtype
    }
    pub fn clear_dtype(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_dtype(&mut self, v: super::types::DataType) {
        self.dtype = v;
    }

    // .tensorflow.TensorShapeProto shape = 2;


    pub fn get_shape(&self) -> &super::tensor_shape::TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <super::tensor_shape::TensorShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: super::tensor_shape::TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut super::tensor_shape::TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> super::tensor_shape::TensorShapeProto {
        self.shape.take().unwrap_or_else(|| super::tensor_shape::TensorShapeProto::new())
    }

    // bool trainable = 3;


    pub fn get_trainable(&self) -> bool {
        self.trainable
    }
    pub fn clear_trainable(&mut self) {
        self.trainable = false;
    }

    // Param is passed by value, moved
    pub fn set_trainable(&mut self, v: bool) {
        self.trainable = v;
    }

    // .tensorflow.VariableSynchronization synchronization = 4;


    pub fn get_synchronization(&self) -> super::variable::VariableSynchronization {
        self.synchronization
    }
    pub fn clear_synchronization(&mut self) {
        self.synchronization = super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO;
    }

    // Param is passed by value, moved
    pub fn set_synchronization(&mut self, v: super::variable::VariableSynchronization) {
        self.synchronization = v;
    }

    // .tensorflow.VariableAggregation aggregation = 5;


    pub fn get_aggregation(&self) -> super::variable::VariableAggregation {
        self.aggregation
    }
    pub fn clear_aggregation(&mut self) {
        self.aggregation = super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE;
    }

    // Param is passed by value, moved
    pub fn set_aggregation(&mut self, v: super::variable::VariableAggregation) {
        self.aggregation = v;
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string device = 7;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // repeated .tensorflow.SavedVariable experimental_distributed_variable_components = 8;


    pub fn get_experimental_distributed_variable_components(&self) -> &[SavedVariable] {
        &self.experimental_distributed_variable_components
    }
    pub fn clear_experimental_distributed_variable_components(&mut self) {
        self.experimental_distributed_variable_components.clear();
    }

    // Param is passed by value, moved
    pub fn set_experimental_distributed_variable_components(&mut self, v: ::protobuf::RepeatedField<SavedVariable>) {
        self.experimental_distributed_variable_components = v;
    }

    // Mutable pointer to the field.
    pub fn mut_experimental_distributed_variable_components(&mut self) -> &mut ::protobuf::RepeatedField<SavedVariable> {
        &mut self.experimental_distributed_variable_components
    }

    // Take field
    pub fn take_experimental_distributed_variable_components(&mut self) -> ::protobuf::RepeatedField<SavedVariable> {
        ::std::mem::replace(&mut self.experimental_distributed_variable_components, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SavedVariable {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experimental_distributed_variable_components {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dtype, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trainable = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.synchronization, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aggregation, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.experimental_distributed_variable_components)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dtype != super::types::DataType::DT_INVALID {
            my_size += ::protobuf::rt::enum_size(1, self.dtype);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trainable != false {
            my_size += 2;
        }
        if self.synchronization != super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO {
            my_size += ::protobuf::rt::enum_size(4, self.synchronization);
        }
        if self.aggregation != super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE {
            my_size += ::protobuf::rt::enum_size(5, self.aggregation);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.device);
        }
        for value in &self.experimental_distributed_variable_components {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dtype != super::types::DataType::DT_INVALID {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.dtype))?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trainable != false {
            os.write_bool(3, self.trainable)?;
        }
        if self.synchronization != super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.synchronization))?;
        }
        if self.aggregation != super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.aggregation))?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.device.is_empty() {
            os.write_string(7, &self.device)?;
        }
        for v in &self.experimental_distributed_variable_components {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedVariable {
        SavedVariable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::types::DataType>>(
                "dtype",
                |m: &SavedVariable| { &m.dtype },
                |m: &mut SavedVariable| { &mut m.dtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor_shape::TensorShapeProto>>(
                "shape",
                |m: &SavedVariable| { &m.shape },
                |m: &mut SavedVariable| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trainable",
                |m: &SavedVariable| { &m.trainable },
                |m: &mut SavedVariable| { &mut m.trainable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::variable::VariableSynchronization>>(
                "synchronization",
                |m: &SavedVariable| { &m.synchronization },
                |m: &mut SavedVariable| { &mut m.synchronization },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::variable::VariableAggregation>>(
                "aggregation",
                |m: &SavedVariable| { &m.aggregation },
                |m: &mut SavedVariable| { &mut m.aggregation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SavedVariable| { &m.name },
                |m: &mut SavedVariable| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &SavedVariable| { &m.device },
                |m: &mut SavedVariable| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SavedVariable>>(
                "experimental_distributed_variable_components",
                |m: &SavedVariable| { &m.experimental_distributed_variable_components },
                |m: &mut SavedVariable| { &mut m.experimental_distributed_variable_components },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedVariable>(
                "SavedVariable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedVariable {
        static instance: ::protobuf::rt::LazyV2<SavedVariable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedVariable::new)
    }
}

impl ::protobuf::Clear for SavedVariable {
    fn clear(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
        self.shape.clear();
        self.trainable = false;
        self.synchronization = super::variable::VariableSynchronization::VARIABLE_SYNCHRONIZATION_AUTO;
        self.aggregation = super::variable::VariableAggregation::VARIABLE_AGGREGATION_NONE;
        self.name.clear();
        self.device.clear();
        self.experimental_distributed_variable_components.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedVariable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedVariable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FunctionSpec {
    // message fields
    pub fullargspec: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    pub is_method: bool,
    pub input_signature: ::protobuf::SingularPtrField<super::struct_pb::StructuredValue>,
    pub jit_compile: FunctionSpec_JitCompile,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FunctionSpec {
    fn default() -> &'a FunctionSpec {
        <FunctionSpec as ::protobuf::Message>::default_instance()
    }
}

impl FunctionSpec {
    pub fn new() -> FunctionSpec {
        ::std::default::Default::default()
    }

    // .tensorflow.StructuredValue fullargspec = 1;


    pub fn get_fullargspec(&self) -> &super::struct_pb::StructuredValue {
        self.fullargspec.as_ref().unwrap_or_else(|| <super::struct_pb::StructuredValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fullargspec(&mut self) {
        self.fullargspec.clear();
    }

    pub fn has_fullargspec(&self) -> bool {
        self.fullargspec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullargspec(&mut self, v: super::struct_pb::StructuredValue) {
        self.fullargspec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullargspec(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.fullargspec.is_none() {
            self.fullargspec.set_default();
        }
        self.fullargspec.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullargspec(&mut self) -> super::struct_pb::StructuredValue {
        self.fullargspec.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }

    // bool is_method = 2;


    pub fn get_is_method(&self) -> bool {
        self.is_method
    }
    pub fn clear_is_method(&mut self) {
        self.is_method = false;
    }

    // Param is passed by value, moved
    pub fn set_is_method(&mut self, v: bool) {
        self.is_method = v;
    }

    // .tensorflow.StructuredValue input_signature = 5;


    pub fn get_input_signature(&self) -> &super::struct_pb::StructuredValue {
        self.input_signature.as_ref().unwrap_or_else(|| <super::struct_pb::StructuredValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_signature(&mut self) {
        self.input_signature.clear();
    }

    pub fn has_input_signature(&self) -> bool {
        self.input_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_signature(&mut self, v: super::struct_pb::StructuredValue) {
        self.input_signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_signature(&mut self) -> &mut super::struct_pb::StructuredValue {
        if self.input_signature.is_none() {
            self.input_signature.set_default();
        }
        self.input_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_signature(&mut self) -> super::struct_pb::StructuredValue {
        self.input_signature.take().unwrap_or_else(|| super::struct_pb::StructuredValue::new())
    }

    // .tensorflow.FunctionSpec.JitCompile jit_compile = 6;


    pub fn get_jit_compile(&self) -> FunctionSpec_JitCompile {
        self.jit_compile
    }
    pub fn clear_jit_compile(&mut self) {
        self.jit_compile = FunctionSpec_JitCompile::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_jit_compile(&mut self, v: FunctionSpec_JitCompile) {
        self.jit_compile = v;
    }
}

impl ::protobuf::Message for FunctionSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.fullargspec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fullargspec)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_method = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_signature)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.jit_compile, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fullargspec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_method != false {
            my_size += 2;
        }
        if let Some(ref v) = self.input_signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.jit_compile != FunctionSpec_JitCompile::DEFAULT {
            my_size += ::protobuf::rt::enum_size(6, self.jit_compile);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fullargspec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_method != false {
            os.write_bool(2, self.is_method)?;
        }
        if let Some(ref v) = self.input_signature.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.jit_compile != FunctionSpec_JitCompile::DEFAULT {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.jit_compile))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FunctionSpec {
        FunctionSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                "fullargspec",
                |m: &FunctionSpec| { &m.fullargspec },
                |m: &mut FunctionSpec| { &mut m.fullargspec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_method",
                |m: &FunctionSpec| { &m.is_method },
                |m: &mut FunctionSpec| { &mut m.is_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::struct_pb::StructuredValue>>(
                "input_signature",
                |m: &FunctionSpec| { &m.input_signature },
                |m: &mut FunctionSpec| { &mut m.input_signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FunctionSpec_JitCompile>>(
                "jit_compile",
                |m: &FunctionSpec| { &m.jit_compile },
                |m: &mut FunctionSpec| { &mut m.jit_compile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FunctionSpec>(
                "FunctionSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FunctionSpec {
        static instance: ::protobuf::rt::LazyV2<FunctionSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FunctionSpec::new)
    }
}

impl ::protobuf::Clear for FunctionSpec {
    fn clear(&mut self) {
        self.fullargspec.clear();
        self.is_method = false;
        self.input_signature.clear();
        self.jit_compile = FunctionSpec_JitCompile::DEFAULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FunctionSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FunctionSpec_JitCompile {
    DEFAULT = 0,
    ON = 1,
    OFF = 2,
}

impl ::protobuf::ProtobufEnum for FunctionSpec_JitCompile {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FunctionSpec_JitCompile> {
        match value {
            0 => ::std::option::Option::Some(FunctionSpec_JitCompile::DEFAULT),
            1 => ::std::option::Option::Some(FunctionSpec_JitCompile::ON),
            2 => ::std::option::Option::Some(FunctionSpec_JitCompile::OFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FunctionSpec_JitCompile] = &[
            FunctionSpec_JitCompile::DEFAULT,
            FunctionSpec_JitCompile::ON,
            FunctionSpec_JitCompile::OFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FunctionSpec_JitCompile>("FunctionSpec.JitCompile", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FunctionSpec_JitCompile {
}

impl ::std::default::Default for FunctionSpec_JitCompile {
    fn default() -> Self {
        FunctionSpec_JitCompile::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for FunctionSpec_JitCompile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SavedResource {
    // message fields
    pub device: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SavedResource {
    fn default() -> &'a SavedResource {
        <SavedResource as ::protobuf::Message>::default_instance()
    }
}

impl SavedResource {
    pub fn new() -> SavedResource {
        ::std::default::Default::default()
    }

    // string device = 1;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SavedResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SavedResource {
        SavedResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &SavedResource| { &m.device },
                |m: &mut SavedResource| { &mut m.device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SavedResource>(
                "SavedResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SavedResource {
        static instance: ::protobuf::rt::LazyV2<SavedResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SavedResource::new)
    }
}

impl ::protobuf::Clear for SavedResource {
    fn clear(&mut self) {
        self.device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SavedResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SavedResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveableObject {
    // message fields
    pub save_function: i32,
    pub restore_function: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SaveableObject {
    fn default() -> &'a SaveableObject {
        <SaveableObject as ::protobuf::Message>::default_instance()
    }
}

impl SaveableObject {
    pub fn new() -> SaveableObject {
        ::std::default::Default::default()
    }

    // int32 save_function = 2;


    pub fn get_save_function(&self) -> i32 {
        self.save_function
    }
    pub fn clear_save_function(&mut self) {
        self.save_function = 0;
    }

    // Param is passed by value, moved
    pub fn set_save_function(&mut self, v: i32) {
        self.save_function = v;
    }

    // int32 restore_function = 3;


    pub fn get_restore_function(&self) -> i32 {
        self.restore_function
    }
    pub fn clear_restore_function(&mut self) {
        self.restore_function = 0;
    }

    // Param is passed by value, moved
    pub fn set_restore_function(&mut self, v: i32) {
        self.restore_function = v;
    }
}

impl ::protobuf::Message for SaveableObject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.save_function = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.restore_function = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.save_function != 0 {
            my_size += ::protobuf::rt::value_size(2, self.save_function, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.restore_function != 0 {
            my_size += ::protobuf::rt::value_size(3, self.restore_function, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.save_function != 0 {
            os.write_int32(2, self.save_function)?;
        }
        if self.restore_function != 0 {
            os.write_int32(3, self.restore_function)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SaveableObject {
        SaveableObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "save_function",
                |m: &SaveableObject| { &m.save_function },
                |m: &mut SaveableObject| { &mut m.save_function },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "restore_function",
                |m: &SaveableObject| { &m.restore_function },
                |m: &mut SaveableObject| { &mut m.restore_function },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SaveableObject>(
                "SaveableObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SaveableObject {
        static instance: ::protobuf::rt::LazyV2<SaveableObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SaveableObject::new)
    }
}

impl ::protobuf::Clear for SaveableObject {
    fn clear(&mut self) {
        self.save_function = 0;
        self.restore_function = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveableObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveableObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1tensorflow/core/protobuf/saved_object_graph.proto\x12\ntensorflow\x1a\
    ,tensorflow/core/framework/tensor_shape.proto\x1a%tensorflow/core/framew\
    ork/types.proto\x1a(tensorflow/core/framework/variable.proto\x1a(tensorf\
    low/core/framework/versions.proto\x1a%tensorflow/core/protobuf/struct.pr\
    oto\x1a5tensorflow/core/protobuf/trackable_object_graph.proto\"\x8e\x02\
    \n\x10SavedObjectGraph\x12-\n\x05nodes\x18\x01\x20\x03(\x0b2\x17.tensorf\
    low.SavedObjectR\x05nodes\x12b\n\x12concrete_functions\x18\x02\x20\x03(\
    \x0b23.tensorflow.SavedObjectGraph.ConcreteFunctionsEntryR\x11concreteFu\
    nctions\x1ag\n\x16ConcreteFunctionsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x127\n\x05value\x18\x02\x20\x01(\x0b2!.tensorflow.SavedC\
    oncreteFunctionR\x05value:\x028\x01\"\xa7\x07\n\x0bSavedObject\x12\\\n\
    \x08children\x18\x01\x20\x03(\x0b2@.tensorflow.TrackableObjectGraph.Trac\
    kableObject.ObjectReferenceR\x08children\x12m\n\x0eslot_variables\x18\
    \x03\x20\x03(\x0b2F.tensorflow.TrackableObjectGraph.TrackableObject.Slot\
    VariableReferenceR\rslotVariables\x12>\n\x0buser_object\x18\x04\x20\x01(\
    \x0b2\x1b.tensorflow.SavedUserObjectH\0R\nuserObject\x12.\n\x05asset\x18\
    \x05\x20\x01(\x0b2\x16.tensorflow.SavedAssetH\0R\x05asset\x127\n\x08func\
    tion\x18\x06\x20\x01(\x0b2\x19.tensorflow.SavedFunctionH\0R\x08function\
    \x127\n\x08variable\x18\x07\x20\x01(\x0b2\x19.tensorflow.SavedVariableH\
    \0R\x08variable\x12]\n\x16bare_concrete_function\x18\x08\x20\x01(\x0b2%.\
    tensorflow.SavedBareConcreteFunctionH\0R\x14bareConcreteFunction\x127\n\
    \x08constant\x18\t\x20\x01(\x0b2\x19.tensorflow.SavedConstantH\0R\x08con\
    stant\x127\n\x08resource\x18\n\x20\x01(\x0b2\x19.tensorflow.SavedResourc\
    eH\0R\x08resource\x12E\n\x0fcaptured_tensor\x18\x0c\x20\x01(\x0b2\x1a.te\
    nsorflow.CapturedTensorH\0R\x0ecapturedTensor\x12W\n\x10saveable_objects\
    \x18\x0b\x20\x03(\x0b2,.tensorflow.SavedObject.SaveableObjectsEntryR\x0f\
    saveableObjects\x1a^\n\x14SaveableObjectsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x120\n\x05value\x18\x02\x20\x01(\x0b2\x1a.tensorflow\
    .SaveableObjectR\x05value:\x028\x01B\x06\n\x04kindJ\x04\x08\x02\x10\x03R\
    \nattributes\"\x83\x01\n\x0fSavedUserObject\x12\x1e\n\nidentifier\x18\
    \x01\x20\x01(\tR\nidentifier\x120\n\x07version\x18\x02\x20\x01(\x0b2\x16\
    .tensorflow.VersionDefR\x07version\x12\x1e\n\x08metadata\x18\x03\x20\x01\
    (\tR\x08metadataB\x02\x18\x01\"=\n\nSavedAsset\x12/\n\x14asset_file_def_\
    index\x18\x01\x20\x01(\x05R\x11assetFileDefIndex\"}\n\rSavedFunction\x12\
    -\n\x12concrete_functions\x18\x01\x20\x03(\tR\x11concreteFunctions\x12=\
    \n\rfunction_spec\x18\x02\x20\x01(\x0b2\x18.tensorflow.FunctionSpecR\x0c\
    functionSpec\"Q\n\x0eCapturedTensor\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12+\n\x11concrete_function\x18\x02\x20\x01(\tR\x10concreteFun\
    ction\"\xe3\x01\n\x15SavedConcreteFunction\x12!\n\x0cbound_inputs\x18\
    \x02\x20\x03(\x05R\x0bboundInputs\x12_\n\x1dcanonicalized_input_signatur\
    e\x18\x03\x20\x01(\x0b2\x1b.tensorflow.StructuredValueR\x1bcanonicalized\
    InputSignature\x12F\n\x10output_signature\x18\x04\x20\x01(\x0b2\x1b.tens\
    orflow.StructuredValueR\x0foutputSignature\"\xff\x01\n\x19SavedBareConcr\
    eteFunction\x124\n\x16concrete_function_name\x18\x01\x20\x01(\tR\x14conc\
    reteFunctionName\x12+\n\x11argument_keywords\x18\x02\x20\x03(\tR\x10argu\
    mentKeywords\x12@\n\x1callowed_positional_arguments\x18\x03\x20\x01(\x03\
    R\x1aallowedPositionalArguments\x12=\n\rfunction_spec\x18\x04\x20\x01(\
    \x0b2\x18.tensorflow.FunctionSpecR\x0cfunctionSpec\"-\n\rSavedConstant\
    \x12\x1c\n\toperation\x18\x01\x20\x01(\tR\toperation\"\xc7\x03\n\rSavedV\
    ariable\x12*\n\x05dtype\x18\x01\x20\x01(\x0e2\x14.tensorflow.DataTypeR\
    \x05dtype\x122\n\x05shape\x18\x02\x20\x01(\x0b2\x1c.tensorflow.TensorSha\
    peProtoR\x05shape\x12\x1c\n\ttrainable\x18\x03\x20\x01(\x08R\ttrainable\
    \x12M\n\x0fsynchronization\x18\x04\x20\x01(\x0e2#.tensorflow.VariableSyn\
    chronizationR\x0fsynchronization\x12A\n\x0baggregation\x18\x05\x20\x01(\
    \x0e2\x1f.tensorflow.VariableAggregationR\x0baggregation\x12\x12\n\x04na\
    me\x18\x06\x20\x01(\tR\x04name\x12\x16\n\x06device\x18\x07\x20\x01(\tR\
    \x06device\x12z\n,experimental_distributed_variable_components\x18\x08\
    \x20\x03(\x0b2\x19.tensorflow.SavedVariableR)experimentalDistributedVari\
    ableComponents\"\xae\x02\n\x0cFunctionSpec\x12=\n\x0bfullargspec\x18\x01\
    \x20\x01(\x0b2\x1b.tensorflow.StructuredValueR\x0bfullargspec\x12\x1b\n\
    \tis_method\x18\x02\x20\x01(\x08R\x08isMethod\x12D\n\x0finput_signature\
    \x18\x05\x20\x01(\x0b2\x1b.tensorflow.StructuredValueR\x0einputSignature\
    \x12D\n\x0bjit_compile\x18\x06\x20\x01(\x0e2#.tensorflow.FunctionSpec.Ji\
    tCompileR\njitCompile\"*\n\nJitCompile\x12\x0b\n\x07DEFAULT\x10\0\x12\
    \x06\n\x02ON\x10\x01\x12\x07\n\x03OFF\x10\x02J\x04\x08\x03\x10\x04J\x04\
    \x08\x04\x10\x05\"'\n\rSavedResource\x12\x16\n\x06device\x18\x01\x20\x01\
    (\tR\x06device\"`\n\x0eSaveableObject\x12#\n\rsave_function\x18\x02\x20\
    \x01(\x05R\x0csaveFunction\x12)\n\x10restore_function\x18\x03\x20\x01(\
    \x05R\x0frestoreFunctionBZZUgithub.com/tensorflow/tensorflow/tensorflow/\
    go/core/protobuf/for_core_protos_go_proto\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
